<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在命令行(Terminal)中自动生成二维码]]></title>
    <url>%2Fblog%2Fgenerate-qr-code-in-terminal%2F</url>
    <content type="text"><![CDATA[shell小白，此脚本实现的功能是在命令行中自动生成输入的文字/链接的二维码 相关资源 brew: 或许是mac上安装软件最方便的方式？ https://brew.sh/ qrencode: “a fast and compact QR Code encoding library” https://github.com/fukuchi/libqrencode 实现思路 检测brew环境，若没有，则安装 检测qrencode环境，活没有，则安装 使用qrencode生成二维码，并打印 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env bash#若没有brew环境，安装brewif which brew &gt; /dev/null ; then echo "brew has been installed."else echo "brew not installed, install brew first." ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"fi#若没有qrencode库，安装qrencodeif which qrencode &gt; /dev/null ; then echo "qrencode has been installed."else echo "qrencode not installed, install brew first" brew install qrencodefi#处理参数，获取要生成二维码的信息if [ $# == 0 ]; then read -p "Enter message here: " messageelif [[ $1 == "help" ]] || [[ $1 == "--help" ]]; then echo "A tool for generating qr code." echo "Example usage:" echo " qrcode \"http://www.163.com\"" echo " qrcode \"n 55!W\"" echo "Further help:" echo " qrcode help" echo " qrcode --help" exitelif [ $1 ]; then message=$1fi#打印二维码echo $message | qrencode -o - -t UTF8 运行效果]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>QR Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google I/O 2018 - (一) Keynote]]></title>
    <url>%2Fblog%2Fgoogle-io-2018-1-keynote%2F</url>
    <content type="text"><![CDATA[2018年Google I/O大会5月8日–5月10日美国加利福尼亚州芒廷维尤海岸线圆形剧场举行，这一系列文章是观看视频录像的笔记，此文为第一部分，Keynote Google I/O 2018一. KeynoteI/O大会官网：https://events.google.com/io 视频链接：https://www.youtube.com/watch?time_continue=441&amp;v=ogfYd705cRs 1. AI1.1 一些应用场景 语音拆分（7:24） 语音生成（摩尔斯电码） 邮件 输入联想 摄像 一些图像识别 1.2 Google Assistant &amp; Google Duplex Holy -&gt; Siri?（”Hey Google”） 然而。。尴尬的事情。。 Continued conversation、Google Assistant其他使用场景 1.3 Naturally conversation New voices Continued conversation Multiple actions Pretty please Google Assistant 打电话订理发、订饭店 Google duplex 亮点，根本听不出来是机器人(36:30) 1.3 Digital Wellbeing Youtube，看了多久提示该休息了，notification整合 2. Google News2.1 Keep up with news you care about Newscast 2.2 Understand the full story full coverage (专题)（更全面事件的发展 local coverage, time line ） 2.3 Enjoy and support the news sources you love Newsstand(杂志摊) Subscribe with Google -&gt; search we’re rolling out on Android iOS and the web in a hundred and twenty seven countries starting today 3. Android P Android started with a simple goal of bringing open standards to the mobile industry 宣传了一波“OPEN” 开放性 10年 3.1 Android P的三个主题 Intelligence Simplicity Digital wellbeing 3.2 Intelligence3.2.1 Adaptive Battery 3.2.2 Adaptive Brightness 3.2.3 App Actions &amp; Slice 预测下一个应用 -&gt; 预测下一个行为 搜索、语音、应用商店 Slice: app提供一些内容给其他app调用，如搜索结果(spotlight) 3.2.4 ML Kit cross-platfrom Android &amp; iOS 3.3 Simplicity 功能键的衍变 手势+小方块（iPhone X）、旋转等 3.4 Digital wellbeing3.4.1 Dashboard App usage notification 3.4.2 App Timer3.4.3 Do Not Disturb -&gt; Shush Starred Contacts 3.4.4 Wind Down Mode屏幕变灰，帮助睡前少玩手机 3.5 Android P Beta 4. Google Maps 谷歌地图变得更加社交化 match cooperation with carema 增强现实 4.1 GPS -&gt; VPS(Visual Positioning System)4.2 Google Lens4.2.1 Smart text selection 4.2.2 Sytle match 4.2.3 Real-time results 5. Self-driving Cars（WAYMO） 这老哥生活应该挺丰富多彩…… back in those early days Google was perhaps the only company in the world investing in both AI and self-driving technology at the same time 5.1 Perception5.2 Behavior prediction5.3 Decision-making5.4 Mapping]]></content>
      <categories>
        <category>Sight</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Sight</tag>
        <tag>Google I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android历史版本]]></title>
    <url>%2Fblog%2Fandroid-api-history-version%2F</url>
    <content type="text"><![CDATA[Android历史版本信息，code name &amp; version &amp; API level &amp; release date Code name Version API level Release date — 1.0 1 2008.09.23 Petit Four 1.1 2 2009.02.09 Cupcake 1.5 3 2009.04.27 Donut 1.6 4 2009.09.15 Éclair 2.0-2.1 5-7 2009.10.26 Froyo 2.2 8 2010.05.20 Gingerbread 2.3 9 2010.12.6 Honeycomb 3.0-3.2 11-13 2011.02.22 Ice Cream Sandwich 4.0 14-15 2011.10.18 Jelly Bean 4.1-4.3 16-18 2012.07.09 KitKat 4.4 19-20 2012.10.31 Lollipop 5.0-5.1 21-22 2014.12.12 Marshmallow 6.0 23 2015.10.05 Nougat 7.0-7.1 24-25 2016.08.22 Oreo 8.0 26 2017.08.21 P 9.0]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git将修改提交到已经commit的n次提交之前]]></title>
    <url>%2Fblog%2Fgit-commit-to-swh%2F</url>
    <content type="text"><![CDATA[在使用git的过程中，遇到了想把新的修改添加到之前的提交中的情况。如果想追加到最后一次提交，那很好办，直接git commit --amend就可以；如果想提交到之前的某次提交，那就有点麻烦了 想法1: 使用stash （❌）1.1 实现步骤： 依次将倒序过去的每次提交git reset --soft后用stash存起来 将要追加的修改commit —amend添加进去 依次将每个stash pop应用出来 1.2 遇到的问题： 使用stash保存，发现apply的时候需要重新commit，达不到好的自动化效果 reset的时候需要将每次commit的信息保存好，再次commit的时候使用，麻烦 想法2: 使用patch+stash （✅）2.1 实现步骤： 将现有修改stash贮存 将距离目标commit中间的若干提交生成patch 将仓库reset --hard到目标commit 应用stash，追加到目标commit 将patch恢复，删除缓存patch文件 2.1 具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env bash### 参数为倒数第n次提交### 判断参数是否合法if [ $# == 0 ] ;then echo "there should be an args" exitfiif [ $1 == "help" ] ;then echo "将现有修改提交到n次提交之前" echo "比如commit1&lt;-commit2&lt;-commit3,提交到commit1,则参数为2" exitfiif [ $1 -gt 0 ] 2&gt;/dev/null ;then echo "git add to commit HEAD~$a"else echo "$1 should be a number" exitfi# 正题n=$1# 将现有修改添加到stashgit add .git stash# 将中间n次提交打patchgit format-patch HEAD~$n --numbered-files -o ~/patchtemp# 将git强制reset到n次提交之前git reset --hard HEAD~$n# 将stash应用,并添加到目标提交git stash apply stash@&#123;0&#125;git add .git commit --amend# 将各个patch恢复declare -i i=1while((i&lt;=$n))do git am -s &lt; ~/patchtemp/$i let ++idone# 删除patchrm -r ~/patchtemp]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文加密测试]]></title>
    <url>%2Fblog%2Fhexo-encrypt-blog-example%2F</url>
    <content type="text"><![CDATA[下面输入密码, 错了就打不开哈哈哈哈 U2FsdGVkX1+32PGpXubavq9LvHpvSccMdKKzN9AgtRoOycZF9fYNPS/tq/euv5YK1y5Z8SgMqO5UdUSpovnCO3ABQyRLVf8iaehfu/p+6vbENlI5uNA5HbsRtbAxD1JjtCjbk/iuKNPEFyXPcBtFx9vi2P25K6Tt3z+OJhTxoA/wfDn9s9uTd7iYbCp0FwMuCsK2pI7QksSjbjqxqcOaP5J2LBvOANjijmSZ10/1/sFZQx1Of/Cz4fMpgS0kYYPWGDhFFKGDAYK8kPiWBt75XZI1dy1l8GAcl6In3y0Gf/l6ksHr2EujR4RreDCAoGNDZSjk6VudqrSnxtSufUtyhZ5KCig4FslfuISDTKS7a0Q87moYOfPVzLIzoDozvosuYmnlp8Ppx6RNCnLQY61i4GuqGoBpmJDrVKuIFYl5U5pj2hdCE6RxJnPJSu7m7wJ5PMPLVYjOmlTCjfE60RT2++9GRiToLj7Emy8QhYKti5Z9aFfUUsZuYPGJPYM/aAMSZ0zTYn4MrdjNR0ATp/INxikJsQx/f9LmAkKCwGNZP6ohWNefLaIWpvT1iABc/jZrtTVA6zLSa9xK9QknfdzLbWb3XpvyGpHWrFohxTLPDDuDuqEhONG2FxUYRNXQc6zULfWZXQE3aNhW8z/WiEWs0dskqa2wNHjJCaS5bSnMH7lJXYeu7JjRmAdFytFq6bmVYGn925DtaredlgC4izFtUCw1XjQFcFIQVnXkdVzE1NPMCSRdGOn1Z3+1QpjWENaS42IWeJJTIM/p/qUEcxeXb84gItpX0TSL6sDvvE6ugHWMr1Q5n7YDK1IsBPgVo7yAfzr+u+wLLxUxHTgYPiUQ1j1tKPanx4IMf2QNoTggqKRrXBKFbtr1hJmyYz8hjfHwEPTA+TUfU3+znzVMhTO59nHOQSH6nfwjV6KBljCtlT6HSLguKwA16WQgSSEuAgI0ScXC0fXXNQkJHRACMmuno2k31U3T41fMDWzy5OUln6h6aK/Wxzz7vX4XJDVUtgKtjVA6ue5+qj/2ReY4ZBwL3oVmGT/Q1AsubWZpnFzYQtfAtOrCKKmZOZewmG5wY4gHHFxdYzbUK5VVfZgOVgBl0uDXHhfns7jHKTGuVmZ/70zzsYmF4OeGHAHSKC/RY0wkfKF9elAHjdsy2p8kNv76/94+H5q8SqzCtfdvKbouX3s=]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给博文加密]]></title>
    <url>%2Fblog%2Fhexo-encrypt-blog%2F</url>
    <content type="text"><![CDATA[博客当然也要有记录生活的功能，怎么能放心的记(tu)录(cao)生活而不担心被陌生人看到呢，那就需要对博文进行加密了。本文介绍了使用hexo-blog-encrypt插件完成对博文进行加密的方式，可以放心的写一些羞羞的事情了~ 通过hexo-blog-encrypt插件实现，插件github地址：https://github.com/MikeCoder/hexo-blog-encrypt ，上面有使用方式的介绍 1. 安装encrypt插件在hexo根目录下的package.json中dependencies标签下添加： 1"hexo-blog-encrypt": "2.0.*" 更新环境安装插件 1$ npm install 2. 在配置文件中启用插件在站点配置文件 _config.yml中启用插件，添加如下配置 1234# Security## Docs: https://github.com/MikeCoder/hexo-blog-encryptencrypt: enable: true 3. 使用encrypt插件加密文章在文章头中添加password字段 123456---title: hello worldpassword: liushaoxiaabstract: 加密文章的简介message: 输入密码上方的提示--- 4. live demodemo: 博文加密测试 , 密码是liushaox 5. 高阶使用方式可以对文章目录TOC进行加密、修改加密模板，具体方式转步插件作者wiki查看： github：https://github.com/MikeCoder/hexo-blog-encrypt/ 中文版：https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用进阶命令使用笔记]]></title>
    <url>%2Fblog%2Fgit-advanced-command-note%2F</url>
    <content type="text"><![CDATA[本文记录了使用git过程中常用的命令，因git基础命令多数人都知道，所以把常用的进阶命令写在前面，也当作是自己的笔记。文章中间有几个使用git遇到的小问题，还挺有意思，给出我的解决方案作为参考～ 建议多查官网 https://git-scm.com/bookhttps://git-scm.com/book/zh/v2 常用进阶命令1. 修改仓库/分支信息12git remote set-url origin https://xxx.git #修改整个仓库的远程位置git branch --set-upstream-to=origin/master #修改当前分支关联的远程分支 2. 修改提交信息(commit message)12git commit --amend #修改上一次提交的commit messagegit rebase -i HEAD~n #修改上n次提交的commit message（也可以用来删除某次提交） 3. 将修改追加到上次到提交12git add . git commit --ammend #多用途 4. 撤销add12git reset HEAD #全部撤销git reset HEAD your_file_path #撤销单个文件 5. 查看git信息123456git config --list #查看git整体配置信息列表git remote -v #查看远程仓库地址git branch -v #查看本地分支&amp;基本信息git branch -vv #比上条多了关联的远程分支（pull/fetch的分支）git branch -r #查看所有远程分支git branch -a #查看所有分支 6. stash123456git stashgit stash save "message" #将stash命名为messagegit stash save -a "message" #将git忽略的文件也stash，不常用git stash list #stash列表git stash pop #将stash第0条应用并删除git stash apply stash@&#123;2&#125; #将index=2的stash应用 7. patch1234567git format-patch HEAD^ #HEAD的patchgit format-patch HEAD^^ #HEAD和前一个的patchgit format-patch HEAD~$n -o ~/patchdir #将前n次提交打patch，保存到～/patchdir目录下git format-patch HEAD~$n --numbered-files #将前n次提交打patch，文件名保存为数字git apply --stat xxx.patch #检查patchgit apply --check xxx.patch #查看是否能应用成功git am -s &lt; xxx.patch #应用patch 8. 创建新分支12git checkout -b feature/dev_liuxiaogit checkout -b feature/dev_liuxiao --track origin/master #基于远程跟踪分支master创建本地分支 9. pull/fetch/push12345678910111213141516171819202122#1. pullgit pull origin master:dev #拉取远程master分支，和本地dev分支合并git pull --rabase origin master:dev #拉取远程master分支，和本地dev分支使用rebase的方式合并#如果本地和远程分支之间存在追踪关系（tracking），可以省略分支名git pull origingit branch --set-upstream dev origin/master #将本地dev分支建立远程追踪分支为origin/master#2. fetch #pull相当于fetch+mergegit fetch origin #拉取远程更新git merge origin/master #将远程更新合并到本地当前分支#3. push#-ugit push -u origin dev #将本地dev分支push到远端#-u 相当于 没有参数+upstreamgit branch --set-upstream dev origin/mastergit push origin dev#-fgit push -f origin dev #将本地dev分支强行push到远端，冲突强行覆盖（保护的分支需要权限）#如果本地分支名和远程目标分支名不同git push origin HEAD:master 10. 删除123git clean -f #删除untracked filesgit clean -f -n #查看会删除的filesgit clean -f -d #删除untracked文件夹 11. log12git reflog #历史记录 #可以拿到已经回滚reset过的提交的id，通过git reset id，可以把回滚过的提交找回 可思考/研究的常见问题1. 如何删除一个远程分支？12345#方式1. git UI操作，通常在setting/branches中#方式2. 将一个空目录提交到制定远程git push origin:dev#方式3. delete参数git push origin -delete dev 2. 如何将修改追加到已经push了的n次提交之前？基础1. 安装git环境1sudo apt-get install git-core #windows在官网下载环境 2. 创建代码仓库 配置身份 12git config --global user.name "liushaox"git config --global user.email "liushaox@163.com" 查看身份 12git config --global user.namegit config --global user.email 初始化为git文件夹 1git init 3. 提交本地代码1234git add AndroidMainfest.xml #添加单个文件git add src #添加单个文件夹git add . #添加所有文件git commit -m "first commit" #添加提交描述信息 4. 状态相关123git status #查看git状态，包括commit、修改、冲突等git diff #查看更改内容git diff app/src/main/java/activity/MainActivity.java #查看单个文件更改内容 5. 常见操作流程123456789101112# clonegit clone https://xxx.git# 第一次上传git initgit add . git commit -m "commit message"git remote add origin https://xxx.gitgit push -u origin master# 以后上传git add . git commit -m "commit message"git push -u origin master]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
